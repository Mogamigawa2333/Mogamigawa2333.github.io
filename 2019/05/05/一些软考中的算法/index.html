<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Noto+Sans+SC:500,700|Source+Code+Pro:500,600&amp;subset=chinese-simplified/css?family=Noto Sans SC, Source Code Pro, sans-serif, monospace:300,300italic,400,400italic,700,700italic|Noto Sans SC, Source Code Pro, sans-serif:300,300italic,400,400italic,700,700italic|Source Code Pro, Noto Sans SC, sans-serif:300,300italic,400,400italic,700,700italic|Source Code Pro, Noto Sans SC, monospace, sans-serif:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法 排序,">










<meta name="description" content="算法的英文翻译 Algorithm 来自于波斯(阿拉伯?)数学家花拉子密,他的《代数学》是第一本解决一次方程及一元二次方程的系统著作,他因而被称为代数的创造者,从此有了十进制 (So..阿拉伯数字?) 以wiki为教科书,加网上各路人马的总结, 再加一点个人的理解,形成了这篇博客在所有的排序算法的代码实现中, 不同作用(步骤)的代码段 我会用空行来分隔开">
<meta name="keywords" content="算法 排序">
<meta property="og:type" content="article">
<meta property="og:title" content="KMP算法和一些排序算法">
<meta property="og:url" content="http://yoursite.com/2019/05/05/一些软考中的算法/index.html">
<meta property="og:site_name" content="最上川">
<meta property="og:description" content="算法的英文翻译 Algorithm 来自于波斯(阿拉伯?)数学家花拉子密,他的《代数学》是第一本解决一次方程及一元二次方程的系统著作,他因而被称为代数的创造者,从此有了十进制 (So..阿拉伯数字?) 以wiki为教科书,加网上各路人马的总结, 再加一点个人的理解,形成了这篇博客在所有的排序算法的代码实现中, 不同作用(步骤)的代码段 我会用空行来分隔开">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-16T10:30:36.650Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KMP算法和一些排序算法">
<meta name="twitter:description" content="算法的英文翻译 Algorithm 来自于波斯(阿拉伯?)数学家花拉子密,他的《代数学》是第一本解决一次方程及一元二次方程的系统著作,他因而被称为代数的创造者,从此有了十进制 (So..阿拉伯数字?) 以wiki为教科书,加网上各路人马的总结, 再加一点个人的理解,形成了这篇博客在所有的排序算法的代码实现中, 不同作用(步骤)的代码段 我会用空行来分隔开">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/05/一些软考中的算法/">





  <title>KMP算法和一些排序算法 | 最上川</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">最上川</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/一些软考中的算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chiu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最上川">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">KMP算法和一些排序算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-05T17:11:03+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>算法的英文翻译 Algorithm 来自于波斯(阿拉伯?)数学家花拉子密,他的《代数学》是第一本解决一次方程及一元二次方程的系统著作,他因而被称为代数的创造者,从此有了十进制 (So..阿拉伯数字?)</p>
<p>以wiki为教科书,加网上各路人马的总结, 再加一点个人的理解,形成了这篇博客<br>在所有的<strong>排序算法</strong>的代码实现中, 不同作用(步骤)的代码段 我会用空行来分隔开</p>
<a id="more"></a>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序:"></a>归并排序:</h2><p>1945 年由约翰·冯·诺伊曼首次提出. 该算法是采用分治法(Divide and Conquer)的一个非常典型的应用;</p>
<p>采用分治法:<br>分割：递归地把当前序列平均分割成两半.<br>整合：在保持元素顺序的同时将上一步得到的子序列整合到一起(归并).</p>
<p>递归地把当前序列平均分割成两半: 分割直到每个子序列只有一个元素, 这样每个子序列就都是”有序的”</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程:"></a>过程:</h3><ol>
<li>申请空间,大小为 2 倍的序列长度 (合并空间)</li>
<li>设定两个指针, 最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素,选择相对小的元素放入到合并空间,并移动指针到下一位置</li>
<li>重复步骤 3 直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<h4 id="步骤-3-演算"><a href="#步骤-3-演算" class="headerlink" title="步骤 3 演算:"></a>步骤 3 演算:</h4><p>假设有两个已经排好顺序的数组：int[] arr1 = {2, 7, 8}和 int[] arr2 = {1, 4, 9},还有一个大数组来装载它们 int[] arr = new int[6]; <em>(这里的大数组就是合并空间)</em></p>
<p>比较 arr1[0] 与 arr2[0] , 显然 arr2[0] 比较小, 将 arr2[0] 拿出来, 放入大数组中. 同时 arr2 的指针向后一格;<br>到目前为止: arr={1};</p>
<p>比较 arr1[0] 和 arr2[1] , 显然 arr1[0] 比较小, 将 arr1[0] 拿出来, 放入大数组中. 同时 arr1 的指针向后一格;<br>到目前为止: arr = {1,2};</p>
<p>比较 arr1[1] 和 arr2[1] , 显然 arr2[1] 比较小, 将 arr2[1] 拿出来, 放入大数组中. 同时 arr2 的指针向后一格;<br>到目前为止: arr = {1,2,4};</p>
<p>… …</p>
<p>最后, 我们会将两个已排好序的数组变成一个已排好序的数组 arr = {1,2,4,7,8,9};</p>
<p>步骤 3 所做的动作为:<br>比较,放入大数组, 指针后移;</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><h4 id="Java-版"><a href="#Java-版" class="headerlink" title="Java 版:"></a>Java 版:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 归并排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] result, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分割</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="comment">//递归的退出条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, result, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, result, start2, end2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//整合</span></span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) <span class="comment">// 比较,放入大数组, 指针后移;</span></span><br><span class="line">        result[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1) <span class="comment">//将另一序列剩下的所有元素直接复制到合并序列尾</span></span><br><span class="line">        result[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2) <span class="comment">//将另一序列剩下的所有元素直接复制到合并序列尾</span></span><br><span class="line">        result[k++] = arr[start2++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置共享对象</span></span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = result[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    merge_sort_recursive(arr, result, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 步骤 3 中的后移一格是通过 start1++ 或者 start2++ 实现的, 先取值后计算;</p>
<h4 id="C-语言版本"><a href="#C-语言版本" class="headerlink" title="C 语言版本:"></a>C 语言版本:</h4><p>这其实是跟 Java 版本是一样的, 没有用到多么高级的语法;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序:"></a>快速排序:</h2><p>据传,快速排序是<a href="https://jerkwin.github.io/2013/01/20/%E4%BA%8C%E5%8D%81%E4%B8%96%E7%BA%AA%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">二十世纪最伟大的算法</a>;</p>
<p>快速排序的最直接竞争者是堆排序（Heapsort）. 堆排序通常比快速排序稍微慢, 但是最坏情况的运行时间比快速排序快. 快速排序是经常比较快, 仍然有最坏情况性能的机会.<br>快速排序也与归并排序（Mergesort）竞争, 同样有最坏情况运行时间比快速排序快的优势,而且归并排序是一直稳定排序;</p>
<p>快速排序的基本思想：快速排序使用分治法(Divide and conquer)策略来把一个序列(list)分为较小和较大的 2 个子序列,然后递归地排序两个子序列.</p>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程:"></a>过程:</h3><p>快速排序使用分治法来把一个串(list)分为两个子串(sub-lists).具体算法描述如下：</p>
<ol>
<li>挑选基准值: 从数列中挑出一个元素,称为 “基准”(pivot);</li>
<li>分区: 重新排序数列,所有元素比基准值小的摆放在基准前面,所有元素比基准值大的摆在基准的后面(相同的数可以到任一边).在这个分区退出之后,该基准就处于数列的中间位置.这个称为分区(partition)操作;</li>
<li>递归排序子序列: 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序;</li>
</ol>
<h4 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析:"></a>过程分析:</h4><p>在数组中找一个基准(任意),经过一趟排序后, 基准左边的数都要比基准小, 基准右边的数都要比基准大.基准刚好在最中间;<br>分别将左边的序列和右边的序列都排好序, 就实现了整个序列有序.<br>那么, 左边和右边的序列排序还是与第一趟排序的过程是一样的. 这样 “ 新问题的解法与原问题解法有着相同的形式 “, 适合递归;</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*快速排序*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">qqq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head &gt;= tail || arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) &#123; <span class="comment">//递归退出条件: 数组为空或者数组只有一个元素</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = head, j = tail, pivot = arr[(head + tail) / <span class="number">2</span>]; <span class="comment">//挑选基准值: 选择数组中间的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] &lt; pivot) &#123; <span class="comment">//一直扫描, 直到找到比pivot大的数</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[j] &gt; pivot) &#123; <span class="comment">//一直扫描, 直到找到比pivot小的数</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此时已经分别找到了 比pivot小的数(右边) 和 比pivot大的数(左边) ,它们进行交换, 两侧都向前推进(i++,j--)</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = t;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qSort(arr, head, j);<span class="comment">//左侧递归</span></span><br><span class="line">        qSort(arr, i, tail);<span class="comment">//右侧递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">90</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">77</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        qSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="选择排序-插入排序"><a href="#选择排序-插入排序" class="headerlink" title="选择排序 插入排序:"></a>选择排序 插入排序:</h2><p><a href="https://www.wikiwand.com/zh-hans/%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f" target="_blank" rel="noopener">选择排序</a> 和 <a href="https://www.wikiwand.com/zh-hans/%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f" target="_blank" rel="noopener">插入排序</a> 在 wiki 中都以”简单直观”开头; 我的理解是”能一下子就能让别人明白, 没有那些拐弯抹角的特别设计”; 这两个排序算法分别代表了普通人最容易想到的两种思路;</p>
<p>给一个普通人一个乱序的数组,他会怎么排序呢?</p>
<ol>
<li><p>在内存空间中开辟一个新数组,长度与乱序数组相同. 在乱序数组中找到最小的一个放进新数组的开头. 然后再从剩余的乱序数组中找到最小的,放进新数组的已排序的末尾. 直到完毕. 这就是 选择排序 的基本原理; 也是最简单的一个</p>
</li>
<li><p>类似于打扑克牌时给牌排序.. (修改了很多次文字描述, 还是这个描述”简单直观”, 相关情景立即浮现); 这就是 插入排序 的基本原理;</p>
</li>
</ol>
<h3 id="过程描述"><a href="#过程描述" class="headerlink" title="过程描述:"></a>过程描述:</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序:"></a>选择排序:</h4><ol>
<li>首先在未排序序列中找到最小（大）元素, 存放到排序序列的起始位置.</li>
<li>然后, 再从剩余未排序元素中继续寻找最小（大）元素, 然后放到已排序序列的末尾.</li>
<li>以此类推, 直到所有元素均排序完毕.</li>
</ol>
<p>我敢说, 这是最简单最容易想到的逻辑..</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序:"></a>插入排序:</h4><p>(注意要使用原地排序,节省资源,不要开辟新空间. 我们给扑克排序时是新开辟了一个空间)</p>
<ol>
<li>从第一个元素开始, 该元素可以认为已经被排序</li>
<li>取出下一个元素key, 在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素key, 将该元素移到下一位置</li>
<li>重复步骤3, 直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后(其实就是原地不动)</li>
<li>重复步骤2~5</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现:"></a>代码实现:</h3><h4 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序:"></a>选择排序:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min, temp; <span class="comment">// min:最小值的下标, temp:交换时的中间变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化未排序序列中最小数据数组下标</span></span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 在未排序元素中继续寻找最小元素, 并保存其下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将找到的最小元素放到已排序列末尾</span></span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                temp = arr[min];</span><br><span class="line">                arr[min] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序:"></a>插入排序:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java描述</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123; <span class="comment">//从第一个元素开始, 该元素可以认为已经被排序 (i = 1)</span></span><br><span class="line">        <span class="keyword">int</span> key = array[i]; <span class="comment">// 在数组的原地取下一个未被排序的元素, 新元素key</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>; <span class="comment">// (数组的原地)已排序的数组的最后一个</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123; <span class="comment">// 从后向前扫描, 当key小于已排序的各个元素 时</span></span><br><span class="line">            array[j + <span class="number">1</span>] = array[j]; <span class="comment">// 往后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = key; <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序:"></a>基数排序:</h2><p>基数排序 和 桶排序 是表兄弟. (LSD（Least significant digital）或MSD（Most significant digital）, LSD的排序方式由键值的最右边开始, 而MSD则相反, 由键值的最左边开始)</p>
<p>它的过程是这样的: 将所有待比较数值（正整数）统一为同样的数位长度, 数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次排序. 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列.<br>(过程明白, 但是背后具体的数学原理搞不懂;)</p>
<h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程:"></a>过程:</h3><p><a href="https://segmentfault.com/a/1190000013986116" target="_blank" rel="noopener">过程就三步</a>:</p>
<p>第一趟桶排序将数字的个位数分别<strong>分配</strong>到桶里面去, 然后<strong>回收</strong>起来, 此时数组元素的所有个位数都已经排好顺序了<br>第二趟桶排序将数字的十位数分别<strong>分配</strong>到桶里面去, 然后<strong>回收</strong>起来, 此时数组元素的所有个位数和十位数都已经排好顺序了(如果没有十位数、则补0)<br>第三趟桶排序将数字的百位数分别<strong>分配</strong>到桶里面去, 然后<strong>回收</strong>起来, 此时数组元素的所有个位数和十位数和百位数都已经排好顺序了(如果没有百位数、则补0)<br>…………………………….<br>直至全部数(个、十、百、千位…)排好顺序, 那么这个数组就是有序的了. </p>
<p>三步走战略: <strong>分配 -&gt; 回收 -&gt; 循环</strong></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java描述:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先求出数组最大的值, 然后不断/10, 只要它能大于0, 那么它的位数还有,这个位数决定了遍历的次数</span></span><br><span class="line">    <span class="keyword">int</span> max = findMax(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要遍历的次数由数组最大值的位数来决定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; max / i &gt; <span class="number">0</span>; i = i * <span class="number">10</span>) &#123; <span class="comment">// i = 10,100,1000 ... 三步走战略中的 循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length][<span class="number">10</span>]; <span class="comment">//二维数组的初始值都是0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配: 获取元素的每一位数上的数字, 放进桶里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrays.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arrays[j] / i) % <span class="number">10</span>; <span class="comment">// 元素的个、十、百、千位上的数字</span></span><br><span class="line">            <span class="comment">//将其放入桶里</span></span><br><span class="line">            buckets[j][num] = arrays[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回收: 回收桶里的元素</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//arrays的下标</span></span><br><span class="line">        <span class="comment">//有10个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//对每个桶里的元素进行回收</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arrays.length ; l++) &#123;</span><br><span class="line">                <span class="comment">//如果桶里面有元素就回收(数据初始化会为0)</span></span><br><span class="line">                <span class="keyword">if</span> (buckets[l][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    arrays[k++] = buckets[l][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序:"></a>Shell 排序:</h2><p>插入排序的优化升级版本<br>具体介绍见 <a href="https://www.wikiwand.com/zh-hans/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#/overview" target="_blank" rel="noopener">wikiwand老师(太厉害了)</a></p>
<p>注意: 在希尔排序中, 他们所说的 “增量” 就是 “步长” ;<br>按照<strong>大部分人</strong>的约定俗成的习惯, 可以用一个序列来表示增量：{n/2,(n/2)/2…1}, 每次增量都/2; 毕竟 “约定大于配置”;</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言实现:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap, i, j; <span class="comment">//gap</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">                arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length / <span class="number">2</span>; <span class="comment">// 步长(增量)</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; array.length; i++) &#123;</span><br><span class="line">            temp = array[i]; <span class="comment">// 取每一步的两端</span></span><br><span class="line">            j = i - gap;  <span class="comment">// 取每一步的两端</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &lt; temp) &#123; <span class="comment">//需要注意的是, 這裡array[j] &lt; temp將會使數组從大到小排序. (from wikiwand)</span></span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">                array[j + gap] = array[j];</span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = gap / <span class="number">2</span>; <span class="comment">//按照约定, 步长每次 /2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序:"></a>桶排序:</h2><p>答案: 略. ( ・_ゝ・)</p>
<hr>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序:"></a>堆排序:</h2><p>利用<strong>最大堆</strong>的根节点最大值这个特点来进行排序, 取出堆的根节点,把根节点和数组的最后一个进行交换.并让数组中剩余的数组重新建立一个最大堆;</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释:"></a>名词解释:</h3><ul>
<li>堆: 堆 = 完全二叉树 + 一定规则; So,满足一下三个性质:<ol>
<li>必须是<strong>完全二叉树</strong></li>
<li>用数组实现</li>
<li>任一结点的值是其子树所有结点的最大值或最小值</li>
</ol>
</li>
<li>最大堆:堆的顶点是最大值时, 称为“最大堆”, 也称大顶堆；最小值时, 称为“最小堆”, 也称小顶堆.</li>
<li>完全二叉树: 除了最后一层之外的其他每一层都被完全填充, 并且所有结点都<strong>保持向左对齐</strong>.</li>
<li>堆也是一种优先队列, 队列中允许的操作是先进先出（FIFO）, 在队尾插入元素, 在队头取出元素.<br>而堆也是一样, 在堆底插入元素, 在堆顶取出元素, 但是堆中元素的排列不是按照到来的先后顺序, 而是按照一定的优先顺序排列的.<br>这个优先顺序可以是元素的大小或者其他规则.</li>
<li>优先队列：一种特殊的队列, 队列中元素出栈的顺序是按照元素的优先权大小, 而不是元素入队的先后顺序.</li>
</ul>
<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想:"></a>主要思想:</h3><ul>
<li>最大堆的特点是顶点永远是最大值, 但是剩下的并不一定有序</li>
<li>(原地排序) 找到最大值, 与数组的最后一位交换<br>建堆,交换,建堆,交换,建堆,交换….<br>这, 就是堆排序</li>
</ul>
<h3 id="过程-3"><a href="#过程-3" class="headerlink" title="过程:"></a>过程:</h3><ul>
<li>完全二叉树的节点之间的关系: 如:某节点的下标是a<ul>
<li>a 的左子树的根节点是 left = 2a + 1 ;  // 二叉树,每层节点的数量是上一层节点数量的两倍,再加一(从零开始的…数量=编号+1),即为左子树的位置;</li>
<li>a 的右子树的根节点是 right = 2a + 2 ; //也就是 left + 1</li>
<li>a 的parent是 (a - 1) / 2 ;</li>
</ul>
</li>
</ul>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现:"></a>代码实现:</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  第一步：将数组堆化</span></span><br><span class="line"><span class="comment">         *  beginIndex = 最后一个非叶子节点。</span></span><br><span class="line"><span class="comment">         *  从最后一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">         *  因为叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// (len - 1) / 2 , 最后一个叶子节点的parent(最后一个非叶子节点). "最后一个叶子节点"就是 "数组的最后一位"</span></span><br><span class="line">        System.out.println(beginIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            maxHeapify(i, len);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 第二步：对堆化数据排序</span></span><br><span class="line"><span class="comment">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">         * 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(<span class="number">0</span>, i);</span><br><span class="line">            maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len 未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> ri = li + <span class="number">1</span>;           <span class="comment">// 右子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> cMax = li;             <span class="comment">// 子节点值最大索引，默认左子节点. </span></span><br><span class="line">        <span class="keyword">if</span> (li &gt; len) <span class="keyword">return</span>;      <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">            cMax = ri;</span><br><span class="line">        <span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">            swap(cMax, index);      <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">            maxHeapify(cMax, len);  <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试用例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出：</span></span><br><span class="line"><span class="comment">     * [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int[] arr = new int[] &#123;3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">25</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">59</span>, <span class="number">34</span>, <span class="number">22</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">99</span>, <span class="number">10</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">65</span>, <span class="number">50</span>, <span class="number">88</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">23</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> HeapSort(arr).sort();</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========================================================================================================================</span></span><br><span class="line"><span class="comment">// 第二种描述, 这种描述更接近C语言, Sooo.. you Seee~</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dddd</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1.最大堆的特点是顶点永远是最大值, 但是剩下的并不一定有序</span></span><br><span class="line"><span class="comment">     * 2.(原地排序) 找到最大值, 与数组的最后一位交换</span></span><br><span class="line"><span class="comment">     * 建堆,交换,建堆,交换,建堆,交换....</span></span><br><span class="line"><span class="comment">     * 这就是堆排序</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      left: (i + 1) * 2 - 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      right: (i + 1) * 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      parent: (i - 1) / 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">        buildMaxHeap(arr); <span class="comment">// "构建"初始最大堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i); <span class="comment">//交换</span></span><br><span class="line">            len--; <span class="comment">// 未排序的数组的长度每次减一</span></span><br><span class="line">            heapify(arr, <span class="number">0</span>, len); <span class="comment">//建堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123; <span class="comment">//"构建"初始最大堆</span></span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) Math.floor(length / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">//建堆. i是当前节点</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//左子树的根节点</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">//右子树的根节点</span></span><br><span class="line">        <span class="keyword">int</span> largest = i; <span class="comment">// 最大值的下标(把当前节点看作是最大值)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 作用:</span></span><br><span class="line"><span class="comment">     * 1.将数组中的i与j进行交换</span></span><br><span class="line"><span class="comment">     * 2.将最大值与未排序的数组的最后一位交换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">25</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">59</span>, <span class="number">34</span>, <span class="number">22</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">99</span>, <span class="number">10</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">65</span>, <span class="number">50</span>, <span class="number">88</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">23</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"....."</span> + <span class="string">"a = "</span> + a.length); <span class="comment">// 19</span></span><br><span class="line">        System.out.println(<span class="string">"....."</span> + <span class="string">"(int)Math.floor(a.length / 2) = "</span> + (<span class="keyword">int</span>) Math.floor(a.length / <span class="number">2</span>));<span class="comment">//9</span></span><br><span class="line">        <span class="keyword">int</span>[] b = sort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : b) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="todo-稳定与不稳定-递归-迭代与自顶向下-自底向上-复杂度的计算-各个复杂度的函数图像-迭代和递归的时间和空间复杂度是否有区别-广度优先算法与深度优先算法"><a href="#todo-稳定与不稳定-递归-迭代与自顶向下-自底向上-复杂度的计算-各个复杂度的函数图像-迭代和递归的时间和空间复杂度是否有区别-广度优先算法与深度优先算法" class="headerlink" title="todo: 稳定与不稳定, 递归.迭代与自顶向下.自底向上, 复杂度的计算.各个复杂度的函数图像. 迭代和递归的时间和空间复杂度是否有区别? 广度优先算法与深度优先算法 :"></a>todo: 稳定与不稳定, 递归.迭代与自顶向下.自底向上, 复杂度的计算.各个复杂度的函数图像. 迭代和递归的时间和空间复杂度是否有区别? 广度优先算法与深度优先算法 :</h2><h3 id="原地排序"><a href="#原地排序" class="headerlink" title="原地排序:"></a>原地排序:</h3><p>要尽可能减少内存占用, 能不开辟新空间就不开辟新空间; 就在乱序数列的原地进行排序;<br>这里说的原地排序就是 <strong>内部排序</strong><br>需要开辟新空间的排序算法是 <strong>外部排序</strong></p>
<h3 id="while-与-for-等价-只是易读性有差别"><a href="#while-与-for-等价-只是易读性有差别" class="headerlink" title="while 与 for 等价, 只是易读性有差别"></a>while 与 for 等价, 只是易读性有差别</h3><h3 id="稳定与不稳定"><a href="#稳定与不稳定" class="headerlink" title="稳定与不稳定"></a>稳定与不稳定</h3><h3 id="各个排序算法的时间复杂度"><a href="#各个排序算法的时间复杂度" class="headerlink" title="各个排序算法的时间复杂度:"></a>各个排序算法的时间复杂度:</h3><table>
<thead>
<tr>
<th style="text-align:center">算法:</th>
<th style="text-align:center">选择排序</th>
<th style="text-align:center">插入排序</th>
<th style="text-align:center">归并排序</th>
<th style="text-align:center">快速排序</th>
<th style="text-align:center">基数排序</th>
<th style="text-align:center">希尔排序</th>
<th style="text-align:center">桶排序</th>
<th style="text-align:center">堆排序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">时间复杂度</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">空间复杂度</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法:"></a>KMP算法:</h1><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组:"></a>next数组:</h2><p>(以下图片中的基因片段来自人类基因组的chr6.fa文件)</p>
<script type="text/javascript" src="/js/src/view.min.js"></script>

<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(String pattern, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> patternIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">int</span> nextIndex = - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = pattern.length();</span><br><span class="line">        next[<span class="number">0</span>] = - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (patternIndex &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex == - <span class="number">1</span> || pattern.charAt(nextIndex) == pattern.charAt(patternIndex)) &#123;</span><br><span class="line">                patternIndex++;</span><br><span class="line">                nextIndex++;</span><br><span class="line">                next[patternIndex] = nextIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextIndex = next[nextIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext2</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = pattern.length;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//t为pattern的下标</span></span><br><span class="line">        next[<span class="number">0</span>] = - <span class="number">1</span>; <span class="comment">//钦定, 如果在0位置失配,向下移动一位.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) &#123; <span class="comment">//i为当前的字符串的位置</span></span><br><span class="line">            t = next[i - <span class="number">1</span>]; <span class="comment">//利用到前面的已经计算好的next值</span></span><br><span class="line">            System.out.println(<span class="string">"....."</span> + <span class="string">"t = "</span> + t);</span><br><span class="line">            <span class="comment">//(如果有值:)当前位置的前一个==最长前缀的最后一位,比较最长前缀的最后一位和当前位置是等价的, 不断缩小</span></span><br><span class="line">            <span class="keyword">while</span>   (pattern[t + <span class="number">1</span>] != pattern[i] &amp;&amp; t &gt;= <span class="number">0</span>)<span class="comment">//要么有值,要么等于-1. 等于-1就跳出,</span></span><br><span class="line">                t = next[t];<span class="comment">//如果 next[t] = -1, 就表示红色的部分不存在前后缀相同, 跳出</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------</span></span><br><span class="line">            <span class="keyword">if</span> (pattern[t + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                next[i] = t + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pattern[t + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                next[i] = - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String string, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stringIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slen = string.length();</span><br><span class="line">        <span class="keyword">int</span> plen = pattern.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[plen];</span><br><span class="line"></span><br><span class="line">        getNext2(pattern.toCharArray(), next);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (stringIndex &lt; slen &amp;&amp; patternIndex &lt; plen) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (string.charAt(stringIndex) == pattern.charAt(patternIndex)) &#123;</span><br><span class="line">                stringIndex++;</span><br><span class="line">                patternIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (next[patternIndex] == - <span class="number">1</span>) &#123;</span><br><span class="line">                    stringIndex++;</span><br><span class="line">                    patternIndex = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    patternIndex = next[patternIndex];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (patternIndex == plen) &#123;</span><br><span class="line">                <span class="keyword">return</span> stringIndex - patternIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KMP kmp = <span class="keyword">new</span> KMP();</span><br><span class="line">        String string = <span class="string">"abababdafdasabcfdfeaba"</span>;</span><br><span class="line">        String pattern = <span class="string">"abababdafdasabcfdfeaba"</span>;</span><br><span class="line">        System.out.println(kmp.kmp(string, pattern));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    def index(S, P, pos):</span></span><br><span class="line"><span class="comment">    i = pos</span></span><br><span class="line"><span class="comment">    j = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    while i &lt;= len(S) - 1 and j &lt;= len(P) - 1:</span></span><br><span class="line"><span class="comment">        if S[i] == P[j]:</span></span><br><span class="line"><span class="comment">            i += 1</span></span><br><span class="line"><span class="comment">            j += 1</span></span><br><span class="line"><span class="comment">        else:</span></span><br><span class="line"><span class="comment">            i = i - j + 1</span></span><br><span class="line"><span class="comment">            j = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if j == len(P):</span></span><br><span class="line"><span class="comment">        return i - len(P)</span></span><br><span class="line"><span class="comment">    else:</span></span><br><span class="line"><span class="comment">        return -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">" output: 8 "</span></span><br><span class="line"><span class="comment">print index('abababababca', 'abca', 0)</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="todo-如何在软考的考场上快速求KMP算法的next数组"><a href="#todo-如何在软考的考场上快速求KMP算法的next数组" class="headerlink" title="todo: 如何在软考的考场上快速求KMP算法的next数组"></a>todo: 如何在软考的考场上快速求KMP算法的next数组</h2><hr>
<p>暂时解决方法: 人眼智能观察算法.</p>
<p>继续补充中…</p>
<p>施工参考:<br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法</a><br><a href="https://juejin.im/post/5ab4c7566fb9a028cb2d9126" target="_blank" rel="noopener">Java3y-归并排序</a><br><a href="https://www.wikiwand.com/zh-hans/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F#/%E5%BD%92%E5%B9%B6%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener">wiki-归并排序</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/2315" target="_blank" rel="noopener">漫谈递归</a><br><a href="https://segmentfault.com/a/1190000013888583" target="_blank" rel="noopener">Java3y-快速排序</a><br><a href="https://segmentfault.com/a/1190000004410119" target="_blank" rel="noopener">关于快速排序的四种写法</a><br><a href="https://segmentfault.com/a/1190000013967025" target="_blank" rel="noopener">Java3y-希尔排序</a><br><a href="https://www.wikiwand.com/zh/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">wikiwand_堆排序,可能有错误</a><br><a href="https://juejin.im/post/59fc75f76fb9a0452206dd15" target="_blank" rel="noopener">数据结构:堆</a></p>
<h2 id="知乎关于堆和完全二叉树的讨论"><a href="#知乎关于堆和完全二叉树的讨论" class="headerlink" title="知乎关于堆和完全二叉树的讨论"></a><a href="https://www.zhihu.com/question/36134980" target="_blank" rel="noopener">知乎关于堆和完全二叉树的讨论</a></h2><p>未开始:<br><a href="https://www.jianshu.com/p/b086986969e6" target="_blank" rel="noopener">深度优先搜索和广度优先搜索</a><br><a href="https://www.zhihu.com/question/21387264" target="_blank" rel="noopener">算法时间复杂度</a><br><a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">求算法时间复杂度</a><br><a href="https://www.programcat.com/index/info/id/50" target="_blank" rel="noopener">如何计算时间复杂度</a><br><a href="https://blog.csdn.net/so_geili/article/details/53444816" target="_blank" rel="noopener"></a><br><a href="?">递归树</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法-排序/" rel="tag"># 算法 排序</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/05/C语言的指针/" rel="next" title="C语言的指针">
                <i class="fa fa-chevron-left"></i> C语言的指针
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/31/自动机与正则表达式/" rel="prev" title="RegExp <--> NFA <--> DFA">
                RegExp <--> NFA <--> DFA <i class="fa fa-chevron-right"></i>
              </--></--></a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#排序"><span class="nav-number">1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">1.1.</span> <span class="nav-text">归并排序:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程"><span class="nav-number">1.1.1.</span> <span class="nav-text">过程:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤-3-演算"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">步骤 3 演算:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现"><span class="nav-number">1.1.2.</span> <span class="nav-text">代码实现:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-版"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Java 版:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-语言版本"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">C 语言版本:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">1.2.</span> <span class="nav-text">快速排序:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">过程:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过程分析"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">过程分析:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">代码实现:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序-插入排序"><span class="nav-number">1.3.</span> <span class="nav-text">选择排序 插入排序:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程描述"><span class="nav-number">1.3.1.</span> <span class="nav-text">过程描述:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">选择排序:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">插入排序:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">代码实现:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">选择排序:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序-1"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">插入排序:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-number">1.4.</span> <span class="nav-text">基数排序:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">过程:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">代码实现:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-排序"><span class="nav-number">1.5.</span> <span class="nav-text">Shell 排序:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">代码实现:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序"><span class="nav-number">1.6.</span> <span class="nav-text">桶排序:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序"><span class="nav-number">1.7.</span> <span class="nav-text">堆排序:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#名词解释"><span class="nav-number">1.7.1.</span> <span class="nav-text">名词解释:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要思想"><span class="nav-number">1.7.2.</span> <span class="nav-text">主要思想:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过程-3"><span class="nav-number">1.7.3.</span> <span class="nav-text">过程:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-5"><span class="nav-number">1.7.4.</span> <span class="nav-text">代码实现:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#todo-稳定与不稳定-递归-迭代与自顶向下-自底向上-复杂度的计算-各个复杂度的函数图像-迭代和递归的时间和空间复杂度是否有区别-广度优先算法与深度优先算法"><span class="nav-number">1.8.</span> <span class="nav-text">todo: 稳定与不稳定, 递归.迭代与自顶向下.自底向上, 复杂度的计算.各个复杂度的函数图像. 迭代和递归的时间和空间复杂度是否有区别? 广度优先算法与深度优先算法 :</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原地排序"><span class="nav-number">1.8.1.</span> <span class="nav-text">原地排序:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while-与-for-等价-只是易读性有差别"><span class="nav-number">1.8.2.</span> <span class="nav-text">while 与 for 等价, 只是易读性有差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#稳定与不稳定"><span class="nav-number">1.8.3.</span> <span class="nav-text">稳定与不稳定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各个排序算法的时间复杂度"><span class="nav-number">1.8.4.</span> <span class="nav-text">各个排序算法的时间复杂度:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KMP算法"><span class="nav-number">2.</span> <span class="nav-text">KMP算法:</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#next数组"><span class="nav-number">2.1.</span> <span class="nav-text">next数组:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现-6"><span class="nav-number">2.2.</span> <span class="nav-text">代码实现:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#todo-如何在软考的考场上快速求KMP算法的next数组"><span class="nav-number">2.3.</span> <span class="nav-text">todo: 如何在软考的考场上快速求KMP算法的next数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#知乎关于堆和完全二叉树的讨论"><span class="nav-number">2.4.</span> <span class="nav-text">知乎关于堆和完全二叉树的讨论</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
